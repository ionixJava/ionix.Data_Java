package ionix.Data;

import ionix.Conversion.Convert;
import ionix.Utils.Action;
import ionix.Utils.Delegate;
import ionix.Utils.EventHandlerList;
import ionix.Utils.Ext;
import java.sql.*;
import java.util.*;
import java.util.Date;

//addBatch implementasyonu DbCommand implentasyonu ile yapılacak.
public class DbAccess implements AutoCloseable {
    private final Connection conn;
    public Connection getConnection(){
        return this.conn;
    }

    private final EventHandlerList events;


    public DbAccess(Connection conn) {
        if (null == conn)
            throw new IllegalArgumentException("conn");
        try{
            if (conn.isClosed())
                throw new IllegalArgumentException("Connection is closed");
        }catch (SQLException e){
            throw new RuntimeException(e);
        }

        this.conn = conn;

        this.events = new EventHandlerList();
    }

    private static final Object syncPreExecuteSql = new Object();
    public void onPreExecuteSql(Action<PreExecuteSqlEventArgs> func) {
        this.events.addHandler(syncPreExecuteSql, func);
    }
    public void unPreExecuteSql(Action<PreExecuteSqlEventArgs> func) {
        this.events.removeHandler(syncPreExecuteSql, func);
    }

    private static final Object syncExecuteSqlComplete = new Object();
    public void onExecuteSqlComplete(Action<ExecuteSqlCompleteEventArgs> func) {
        this.events.addHandler(syncExecuteSqlComplete, func);
    }
    public void unExecuteSqlComplete(Action<ExecuteSqlCompleteEventArgs> func) {
        this.events.removeHandler(syncExecuteSqlComplete, func);
    }

    private static void ensureQuery(SqlQuery query){
        if (null == query)
            throw new IllegalArgumentException("query");
    }
    private static void ensureSql(String sql){
        if (Ext.isNullOrEmpty(sql))
            throw new IllegalArgumentException("sql is null or empty");
    }


    //Burasi command nesnelerinden sonra kesinlik kazanıp private yapılcak.
    private PreparedStatement prepareStatement(SqlQuery query, AutoGeneratedKey autoGeneratedKey){
        ensureQuery(query);
        int agk = null == autoGeneratedKey ? 0 : autoGeneratedKey.getValue();

        Delegate d = this.events.get(syncPreExecuteSql);
        if (null != d)
            d.notify(new PreExecuteSqlEventArgs(this, query));

        PreparedStatement ps;
        SqlQueryImpl impl = new SqlQueryImpl(query);
        try {
            ps = this.conn.prepareStatement(impl.getQuery(), agk);
            for (SqlQueryParameter par : query.getParameters()) {
                impl.setObject(ps, par);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return ps;
    }

    private void onCatch(Exception e){
        throw new RuntimeException(e);
    }
    private void onFinally(PreparedStatement ps, SqlQuery query, Date now, Exception ex) {
        Exception closeException = null;
        if (null != ps) {
            try {
                ps.close();
            } catch (SQLException e) {
                closeException = e;
            }
        }

        if (null != closeException){
            if (null != ex)
                ex.addSuppressed(closeException);
            else
                ex = closeException;
        }
        Delegate d = this.events.get(syncExecuteSqlComplete);
        if (d != null)
            d.notify(new ExecuteSqlCompleteEventArgs(this, query, now, new Date(), ex));
        if (null != closeException)
            throw new RuntimeException(closeException);
    }


    public QueryResult executeQuery(SqlQuery query) {
        PreparedStatement ps = this.prepareStatement(query, null);
        ResultSet resultSet = null;
        Exception ex = null;
        Date now = new Date();
        try {
            resultSet = ps.executeQuery();
        } catch (SQLException e) {
            ex = e;
            this.onCatch(e);
        }
        finally {
            this.onFinally(null, query, now, ex);// null == ps will not be closed.
        }
        return new QueryResult(ps, resultSet);
    }
    public QueryResult executeQuery(String sql) {
        ensureSql(sql);
        return this.executeQuery(SqlQuery.toQuery(sql));
    }
    public Object executeScalar(SqlQuery query) {
        Object ret = null;
        try(QueryResult qr = this.executeQuery(query)) {
            try {
                if (qr.getResultSet().next()) {
                    ret = qr.getResultSet().getObject(1);
                }
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
        return ret;
    }
    public Object executeScalar(String sql){
        ensureSql(sql);
        return this.executeScalar(SqlQuery.toQuery(sql));
    }


    public <T> T executeScalar(SqlQuery query, Class<T> cls){
        return (T)Convert.changeType(this.executeScalar(query), cls);
    }
    public <T> T executeScalar(String sql, Class<T> cls){
        ensureSql(sql);
        return this.executeScalar(SqlQuery.toQuery(sql), cls);
    }


    public Iterable executeScalarList(SqlQuery query) {
        ArrayList list = new ArrayList();
        try {
            try (QueryResult qr = this.executeQuery(query)) {
                ResultSet rs = qr.getResultSet();
                while (rs.next()) {
                    list.add(rs.getObject(1));
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return list;
    }
    public Iterable executeScalarList(String sql){
        ensureSql(sql);
        return this.executeScalarList(SqlQuery.toQuery(sql));
    }
    public <T> Iterable<T> executeScalarList(SqlQuery query, Class<T> cls) {
        ArrayList<T> list = new ArrayList();
        Iterable it = this.executeScalarList(query);
        for(Object item : it){
            list.add((T) Convert.changeType(item, cls));
        }
        return list;
    }
    public <T> Iterable<T> executeScalarList(String sql, Class<T> cls){
        ensureSql(sql);
        return this.executeScalarList(SqlQuery.toQuery(sql), cls);
    }


    public boolean execute(SqlQuery query, AutoGeneratedKey autoGeneratedKey) {
        boolean ret = false;
        PreparedStatement ps = this.prepareStatement(query, autoGeneratedKey);
        Exception ex = null;
        Date now = new Date();
        try {
            ret = ps.execute();
        } catch (SQLException e) {
            ex = e;
            this.onCatch(e);
        } finally {
            this.onFinally(ps, query, now, ex);
        }
        return ret;
    }
    public boolean execute(String sql, AutoGeneratedKey autoGeneratedKey){
        ensureSql(sql);
        return this.execute(SqlQuery.toQuery(sql), autoGeneratedKey);
    }
    public boolean execute(SqlQuery query){
        return this.execute(query, null);
    }
    public boolean execute(String sql){
        ensureSql(sql);
        return this.execute(SqlQuery.toQuery(sql));
    }


    public int executeUpdate(SqlQuery query, AutoGeneratedKey autoGeneratedKey) {
        int ret = 0;
        PreparedStatement ps = this.prepareStatement(query, autoGeneratedKey);
        Exception ex = null;
        Date now = new Date();
        try {
            ret = ps.executeUpdate();
        } catch (SQLException e) {
            ex = e;
            this.onCatch(e);
        }
        finally {
            this.onFinally(ps,query,now,ex);
        }
        return ret;
    }
    public int executeUpdate(String sql, AutoGeneratedKey autoGeneratedKey){
        ensureSql(sql);
        return this.executeUpdate(SqlQuery.toQuery(sql), autoGeneratedKey);
    }
    public int executeUpdate(SqlQuery query){
        return this.executeUpdate(query, null);
    }
    public int executeUpdate(String sql){
        ensureSql(sql);
        return this.executeUpdate(SqlQuery.toQuery(sql));
    }


    @Override
    public void close()
    {
        try {
            this.conn.close();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private synchronized static final String parse(StringBuilder query, Map paramMap) {
        int length=query.length();
        StringBuffer parsedQuery=new StringBuffer(length);
        boolean inSingleQuote=false;
        boolean inDoubleQuote=false;
        int index=1;

        for(int i=0;i<length;i++) {
            char c=query.charAt(i);
            if(inSingleQuote) {
                if(c=='\'') {
                    inSingleQuote=false;
                }
            } else if(inDoubleQuote) {
                if(c=='"') {
                    inDoubleQuote=false;
                }
            } else {
                if(c=='\'') {
                    inSingleQuote=true;
                } else if(c=='"') {
                    inDoubleQuote=true;
                } else if((c==':'||c=='@')  && i+1<length &&
                        Character.isJavaIdentifierStart(query.charAt(i+1))) {
                    int j=i+2;
                    while(j<length && Character.isJavaIdentifierPart(query.charAt(j))) {
                        j++;
                    }
                    String name=query.substring(i+1,j);
                    c='?';
                    i+=name.length();

                    List indexList=(List)paramMap.get(name);
                    if(indexList==null) {
                        indexList=new LinkedList();
                        paramMap.put(name, indexList);
                    }
                    indexList.add(new Integer(index));

                    index++;
                }
            }
            parsedQuery.append(c);
        }

        for(Iterator itr = paramMap.entrySet().iterator(); itr.hasNext();) {
            Map.Entry entry=(Map.Entry)itr.next();
            List list=(List)entry.getValue();
            int[] indexes=new int[list.size()];
            int i=0;
            for(Iterator itr2=list.iterator(); itr2.hasNext();) {
                Integer x=(Integer)itr2.next();
                indexes[i++]=x.intValue();
            }
            entry.setValue(indexes);
        }

        return parsedQuery.toString();
    }
    private final class SqlQueryImpl{
        private final Map<String, Object> indexMap;
        private final String query;
        private String getQuery(){
            return this.query;
        }

        private SqlQueryImpl(SqlQuery orginalQuery){
            this.indexMap = new HashMap<>();
            if (orginalQuery.getParameters().getHasNamed()) {
                this.query = parse(orginalQuery.getText(), this.indexMap);
                // System.out.println("getHasNamed == true -> par parse edildi");
            }
            else {
                this.query = orginalQuery.getText().toString();
                // System.out.println("getHasNamed == false -> toString()");
            }
        }

        private void setObject(PreparedStatement st, SqlQueryParameter par) {
            if (par.isNamed()) {
                int[] indexes=(int[])this.indexMap.get(par.getName());
                if(indexes==null) {
                    throw new IllegalArgumentException("Parameter not found: " + par.getName());
                }
                for (int i = 0; i < indexes.length; i++) {
                    try {
                        st.setObject(indexes[i], par.getValue());
                    } catch (SQLException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
            else{
                try {
                    st.setObject(par.getIndex(), par.getValue());
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
