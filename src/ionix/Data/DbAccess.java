package ionix.Data;

import ionix.Conversion.Convert;
import ionix.Utils.*;

import java.sql.*;
import java.util.*;
import java.util.Date;


public class DbAccess implements AutoCloseable {
    private final Connection conn;
    public Connection getConnection(){
        return this.conn;
    }

    private final EventHandlerList events;


    public DbAccess(Connection conn) {
        if (null == conn)
            throw new IllegalArgumentException("conn");
        try{
            if (conn.isClosed())
                throw new IllegalArgumentException("Connection is closed");
        }catch (SQLException e){
            throw new RuntimeException(e);
        }

        this.conn = conn;

        this.events = new EventHandlerList();
    }

    private static final Object syncPreExecuteSql = new Object();
    public void onPreExecuteSql(Action<PreExecuteSqlEventArgs> func) {
        this.events.addHandler(syncPreExecuteSql, func);
    }
    public void unPreExecuteSql(Action<PreExecuteSqlEventArgs> func) {
        this.events.removeHandler(syncPreExecuteSql, func);
    }

    private static final Object syncExecuteSqlComplete = new Object();
    public void onExecuteSqlComplete(Action<ExecuteSqlCompleteEventArgs> func) {
        this.events.addHandler(syncExecuteSqlComplete, func);
    }
    public void unExecuteSqlComplete(Action<ExecuteSqlCompleteEventArgs> func) {
        this.events.removeHandler(syncExecuteSqlComplete, func);
    }


    protected PreparedStatement prepareStatement(SqlQuery query, AutoGeneratedKey autoGeneratedKey, String columnName){//columnName Oracle Squence returns key i√ßin eklendi.
        if (null == query)
            throw new IllegalArgumentException("query");
        int agk = null == autoGeneratedKey ? 0 : autoGeneratedKey.getValue();

        Delegate d = this.events.get(syncPreExecuteSql);
        if (null != d)
            d.notify(new PreExecuteSqlEventArgs(this, query));

        PreparedStatement ps;
        SqlQueryImpl impl = new SqlQueryImpl(query);
        try {
            if (null == columnName)
                ps = this.conn.prepareStatement(impl.getQuery(), agk);
            else
                ps = this.conn.prepareStatement(impl.getQuery(), new String[] { columnName });

            for (SqlQueryParameter par : query.getParameters()) {
                impl.setObject(ps, par);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return ps;
    }

    protected void onCatch(Exception e){
        throw new RuntimeException(e);
    }
    protected void onFinally(PreparedStatement ps, SqlQuery query, Date now, Exception ex) {
        Exception closeException = null;
        if (null != ps) {
            try {
                ps.close();
            } catch (SQLException e) {
                closeException = e;
            }
        }

        if (null != closeException){
            if (null != ex)
                ex.addSuppressed(closeException);
            else
                ex = closeException;
        }
        Delegate d = this.events.get(syncExecuteSqlComplete);
        if (d != null)
            d.notify(new ExecuteSqlCompleteEventArgs(this, query, now, new Date(), ex));
        if (null != closeException)
            throw new RuntimeException(closeException);
    }


    public QueryResult executeQuery(SqlQuery query) {
        PreparedStatement ps = null;
        ResultSet resultSet = null;
        Exception ex = null;
        Date now = new Date();
        try {
            ps = this.prepareStatement(query, null, null);
            resultSet = ps.executeQuery();
        } catch (Exception e) {
            ex = e;
            this.onCatch(e);
        }
        finally {
            this.onFinally(null, query, now, ex);// null == ps will not be closed.
        }
        return new QueryResult(ps, resultSet);
    }

    public Object executeScalar(SqlQuery query) {
        Object ret = null;
        try(QueryResult qr = this.executeQuery(query)) {
            try {
                if (qr.getResultSet().next()) {
                    ret = qr.getResultSet().getObject(1);
                }
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
        return ret;
    }


    public <T> T executeScalar(Class<T> cls, SqlQuery query){
        return (T)Convert.changeType(this.executeScalar(query), cls);
    }


    public Iterable executeScalarList(SqlQuery query) {
        ArrayList list = new ArrayList();
        try {
            try (QueryResult qr = this.executeQuery(query)) {
                ResultSet rs = qr.getResultSet();
                while (rs.next()) {
                    list.add(rs.getObject(1));
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return list;
    }

    public <T> Iterable<T> executeScalarList(Class<T> cls, SqlQuery query) {
        ArrayList<T> list = new ArrayList<>();
        Iterable it = this.executeScalarList(query);
        for(Object item : it){
            list.add((T) Convert.changeType(item, cls));
        }
        return list;
    }


    public boolean execute(SqlQuery query) {
        boolean ret = false;
        PreparedStatement ps = null;
        Exception ex = null;
        Date now = new Date();
        try {
            ps = this.prepareStatement(query, null, null);
            ret = ps.execute();
        } catch (Exception e) {
            ex = e;
            this.onCatch(e);
        } finally {
            this.onFinally(ps, query, now, ex);
        }
        return ret;
    }


    public ExecuteResult executeUpdate(SqlQuery query, AutoGeneratedKey autoGeneratedKey) {
        int returnValue = 0;
        Object generatedKey = null;
        PreparedStatement ps = null;
        Exception ex = null;
        Date now = new Date();
        try {
            ps = this.prepareStatement(query, autoGeneratedKey, null);
            returnValue = ps.executeUpdate();
            if (autoGeneratedKey == AutoGeneratedKey.RETURN_GENERATED_KEYS){
                ResultSet resultSetKeys = ps.getGeneratedKeys();
                if (resultSetKeys.next()){
                    generatedKey = resultSetKeys.getObject(1);
                }
            }
        } catch (Exception e) {
            ex = e;
            this.onCatch(e);
        }
        finally {
            this.onFinally(ps,query,now,ex);
        }
        return new ExecuteResult(returnValue, generatedKey);
    }

    public ExecuteResult executeUpdateSequence(SqlQuery query, String columnName) {
        int returnValue = 0;
        Object generatedKey = null;
        PreparedStatement ps = null;
        Exception ex = null;
        Date now = new Date();
        try {
            ps = this.prepareStatement(query, null, columnName);
            returnValue = ps.executeUpdate();
            if (null != columnName){
                ResultSet resultSetKeys = ps.getGeneratedKeys();
                if (resultSetKeys.next()){
                    generatedKey = resultSetKeys.getObject(1);
                }
            }
        } catch (Exception e) {
            ex = e;
            this.onCatch(e);
        }
        finally {
            this.onFinally(ps,query,now,ex);
        }
        return new ExecuteResult(returnValue, generatedKey);
    }


    @Override
    public void close()
    {
        try {
            this.conn.close();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private synchronized static String parse(StringBuilder query, Map paramMap) {
        int length=query.length();
        StringBuffer parsedQuery=new StringBuffer(length);
        boolean inSingleQuote=false;
        boolean inDoubleQuote=false;
        int index=1;

        for(int i=0;i<length;i++) {
            char c=query.charAt(i);
            if(inSingleQuote) {
                if(c=='\'') {
                    inSingleQuote=false;
                }
            } else if(inDoubleQuote) {
                if(c=='"') {
                    inDoubleQuote=false;
                }
            } else {
                if(c=='\'') {
                    inSingleQuote=true;
                } else if(c=='"') {
                    inDoubleQuote=true;
                } else if((c==':'||c=='@')  && i+1<length &&
                        Character.isJavaIdentifierStart(query.charAt(i+1))) {
                    int j=i+2;
                    while(j<length && Character.isJavaIdentifierPart(query.charAt(j))) {
                        j++;
                    }
                    String name=query.substring(i+1,j);
                    c='?';
                    i+=name.length();

                    List indexList=(List)paramMap.get(name);
                    if(indexList==null) {
                        indexList=new LinkedList();
                        paramMap.put(name, indexList);
                    }
                    indexList.add(new Integer(index));

                    index++;
                }
            }
            parsedQuery.append(c);
        }

        for(Iterator itr = paramMap.entrySet().iterator(); itr.hasNext();) {
            Map.Entry entry=(Map.Entry)itr.next();
            List list=(List)entry.getValue();
            int[] indexes=new int[list.size()];
            int i=0;
            for(Iterator itr2=list.iterator(); itr2.hasNext();) {
                Integer x=(Integer)itr2.next();
                indexes[i++]=x.intValue();
            }
            entry.setValue(indexes);
        }

        return parsedQuery.toString();
    }
    private final class SqlQueryImpl{
        private final Map<String, Object> indexMap;
        private final String query;
        private String getQuery(){
            return this.query;
        }

        private SqlQueryImpl(SqlQuery orginalQuery){
            this.indexMap = new HashMap<>();
            if (orginalQuery.getParameters().getHasNamed()) {
                this.query = parse(orginalQuery.getText(), this.indexMap);
            }
            else {
                this.query = orginalQuery.getText().toString();
            }
        }

        //null deƒüerde ne olacak.
        private void setObject(PreparedStatement st, SqlQueryParameter par) {
            JDBCType dataType = par.getDataType();
            if (par.isNamed()) {
                int[] indexes=(int[])this.indexMap.get(par.getName());
                if(indexes==null) {
                    throw new IllegalArgumentException("Parameter not found: " + par.getName());
                }
                boolean hasDataType = dataType != null;
                for (int i = 0; i < indexes.length; i++) {
                    try {
                        if (hasDataType)
                            st.setObject(indexes[i], par.getValue(), dataType);
                        else
                            st.setObject(indexes[i], par.getValue());
                    } catch (SQLException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
            else{
                try {
                    if (dataType != null)
                        st.setObject(par.getIndex(), par.getValue(), dataType);
                    else
                        st.setObject(par.getIndex(), par.getValue());
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
